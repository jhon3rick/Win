// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var Optiscroll,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(window, document, Math) {

    /*
    	 * CustomEvent polyfill for IE9
    	 * By MDN
    	 * https:#developer.mozilla.org/en-US/docs/Web/API/CustomEvent
    	 * MIT LICENSE
     */
    return typeof window.CustomEvent === 'function' || function(window) {
      var CustomEvent;
      CustomEvent = function(event, params) {
        var evt;
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: void 0
        };
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };
      CustomEvent.prototype = window.Event.prototype;
      return window.CustomEvent = CustomEvent;
    };
  })(window, document, Math);

  Optiscroll = (function() {

    /*
    	 * Variables fijas
     */
    var Events, G, GS, Scrollbar, Utils, _extend, _invoke, _throttle, animationTimeout, cssTest, getScrollbarWidth, toggleClass;
    Optiscroll = function(element, options) {
      var init, me, scrollTo;
      if (options == null) {
        options = {};
      }
      me = this;
      me.cache = {};
      me.element = element;
      me.scrollEl = element.children[0];
      me.settings = _extend(_extend({}, Optiscroll.defaults), options || {});
      init = function() {
        var settings;
        settings = me.settings;
        me.scrollbars = {
          v: new Scrollbar('v', me),
          h: new Scrollbar('h', me)
        };
        if (!document.addEventListener) {
          return;
        }
        if (settings.autoUpdate) {
          G.instances.push(me);
        }
        if (G.nativeScrollbarSize === 0 && indexOf.call(window, 'mozRequestAnimationFrame') >= 0) {
          settings.forceScrollbars = false;
        }
        if (G.nativeScrollbarSize || settings.forceScrollbars) {
          Utils.hideNativeScrollbars(me.scrollEl);
          _invoke(me.scrollbars, 'create');
        }
        if (G.isTouch && settings.preventParentScroll) {
          toggleClass(me.element, settings.classPrefix + '-prevent', true);
        }
        me.update();
        me.bind();
        if (settings.autoUpdate && !G.checkTimer) {
          return Utils.checkLoop();
        }
      };
      me.bind = function() {
        var ev, j, len, listeners, results, scrollEl, varfuncion;
        scrollEl = me.scrollEl;
        listeners = me.listeners = {};
        varfuncion = function(ev) {
          return Events.scroll(ev, me);
        };
        listeners.scroll = _throttle(varfuncion, GS.scrollMinUpdateInterval);
        listeners.overflow = listeners.underflow = listeners.overflowchanged = function() {
          return me.update();
        };
        if (G.isTouch) {
          listeners.touchstart = function(ev) {
            return Events.touchstart(ev, me);
          };
          listeners.touchend = function(ev) {
            return Events.touchend(ev, me);
          };
        }
        if (me.settings.preventParentScroll) {
          listeners.mousewheel = listeners.wheel = function(ev) {
            return Events.wheel(ev, me);
          };
        }
        results = [];
        for (j = 0, len = listeners.length; j < len; j++) {
          ev = listeners[j];
          results.push(scrollEl.addEventListener(ev, listeners[ev]));
        }
        return results;
      };
      me.update = function() {
        var cH, cW, cache, oldcH, sH, sW, scrollEl;
        oldcH = me.cache.clientH;
        scrollEl = me.scrollEl;
        cache = me.cache;
        sH = scrollEl.scrollHeight;
        cH = scrollEl.clientHeight;
        sW = scrollEl.scrollWidth;
        cW = scrollEl.clientWidth;
        if (sH !== cache.scrollH || cH !== cache.clientH || sW !== cache.scrollW || cW !== cache.clientW) {
          cache.scrollH = sH;
          cache.clientH = cH;
          cache.scrollW = sW;
          cache.clientW = cW;
          if (oldcH !== void 0) {
            if (sH === 0 && cH === 0 && !Utils.containsNode(document.body, me.element)) {
              me.destroy();
              false;
            }
            me.fireCustomEvent('sizechange');
          }
          return _invoke(me.scrollbars, 'update');
        }
      };
      init();

      /*
      		 * Animate scrollTo
       */
      scrollTo = function(destX, destY, duration) {
        var cache, endX, endY, startX, startY;
        cache = me.cache;
        G.pauseCheck = true;
        me.update();
        startX = me.scrollEl.scrollLeft;
        startY = me.scrollEl.scrollTop;
        endX = +destX;
        if (destX === 'left') {
          endX = 0;
        }
        if (destX === 'right') {
          endX = cache.scrollW - cache.clientW;
        }
        if (destX === false) {
          endX = startX;
        }
        endY = +destY;
        if (destY === 'top') {
          endY = 0;
        }
        if (destY === 'bottom') {
          endY = cache.scrollH - cache.clientH;
        }
        if (destY === false) {
          endY = startY;
        }
        return me.animateScroll(startX, endX, startY, endY, +duration);
      };
      return {
        scrollIntoView: function(elem, duration, delta) {
          var bottomEdge, eDim, endX, endY, leftEdge, offsetX, offsetY, rightEdge, sDim, scrollEl, startX, startY, topEdge;
          scrollEl = me.scrollEl;
          G.pauseCheck = true;
          me.update();
          if (typeof elem === 'string') {
            elem = scrollEl.querySelector(elem);
          } else if (elem.length && elem.jquery) {
            elem = elem[0];
          }
          if (typeof delta === 'number') {
            delta = {
              top: delta,
              right: delta,
              bottom: delta,
              left: delta
            };
          }
          delta = delta || {};
          eDim = elem.getBoundingClientRect();
          sDim = scrollEl.getBoundingClientRect();
          startX = endX = scrollEl.scrollLeft;
          startY = endY = scrollEl.scrollTop;
          offsetX = startX + eDim.left - sDim.left;
          offsetY = startY + eDim.top - sDim.top;
          leftEdge = offsetX - (delta.left || 0);
          topEdge = offsetY - (delta.top || 0);
          rightEdge = offsetX + eDim.width - me.cache.clientW + (delta.right || 0);
          bottomEdge = offsetY + eDim.height - me.cache.clientH + (delta.bottom || 0);
          if (leftEdge < startX) {
            endX = leftEdge;
          }
          if (rightEdge > startX) {
            endX = rightEdge;
          }
          if (topEdge < startY) {
            endY = topEdge;
          }
          if (bottomEdge > startY) {
            endY = bottomEdge;
          }
          return me.animateScroll(startX, endX, startY, endY, +duration);
        },
        animateScroll: function(startX, endX, startY, endY, duration) {
          var scrollAnimation, scrollEl, startTime;
          scrollEl = me.scrollEl;
          startTime = Date.now();
          if (endX === startX && endY === startY) {
            return;
          }
          if (duration === 0) {
            scrollEl.scrollLeft = endX;
            scrollEl.scrollTop = endY;
            return;
          }
          if (isNaN(duration)) {
            duration = Math.pow(Math.max(Math.abs(endX - startX), Math.abs(endY - startY)), 0.54) * 15;
          }
          scrollAnimation = function() {
            var easedTime, time;
            time = Math.min(1, (Date.now() - startTime) / duration);
            easedTime = Utils.easingFunction(time);
            if (endY !== startY) {
              scrollEl.scrollTop = ~~(easedTime * (endY - startY)) + startY;
            }
            if (endX !== startX) {
              scrollEl.scrollLeft = ~~(easedTime * (endX - startX)) + startX;
            }
            if (time < 1) {
              return animationTimeout(scrollAnimation);
            }
          };
          return animationTimeout(scrollAnimation);
        },
        destroy: function() {
          var ev, index, j, len, listeners, scrollEl;
          scrollEl = me.scrollEl;
          listeners = me.listeners;
          index = G.instances.indexOf(me);
          for (j = 0, len = listeners.length; j < len; j++) {
            ev = listeners[j];
            scrollEl.removeEventListener(ev, listeners[ev]);
          }
          _invoke(me.scrollbars, 'remove');
          scrollEl.removeAttribute('style');
          scrollEl.removeAttribute('data-scroll');
          toggleClass(me.element, me.settings.classPrefix + '-prevent', false);
          if (index > -1) {
            return animationTimeout(function() {
              return G.instances.splice(index, 1);
            });
          }
        },
        fireCustomEvent: function(eventName) {
          var cache, eventData, sH, sW;
          cache = me.cache;
          sH = cache.scrollH;
          sW = cache.scrollW;
          eventData = {
            scrollbarV: _extend({}, cache.v),
            scrollbarH: _extend({}, cache.h),
            scrollTop: cache.v.position * sH,
            scrollLeft: cache.h.position * sW,
            scrollBottom: (1 - cache.v.position - cache.v.size) * sH,
            scrollRight: (1 - cache.h.position - cache.h.size) * sW,
            scrollWidth: sW,
            scrollHeight: sH,
            clientWidth: cache.clientW,
            clientHeight: cache.clientH
          };
          return me.element.dispatchEvent(new CustomEvent(eventName, {
            detail: eventData
          }));
        }
      };
    };
    Events = {
      scroll: function(ev, me) {
        if (!G.pauseCheck) {
          me.fireCustomEvent('scrollstart');
        }
        G.pauseCheck = true;
        me.scrollbars.v.update();
        me.scrollbars.h.update();
        me.fireCustomEvent('scroll');
        clearTimeout(me.cache.timerStop);
        return me.cache.timerStop = setTimeout((function() {
          return Events.scrollStop(me);
        }), me.settings.scrollStopDelay);
      },
      touchstart: function(ev, me) {
        G.pauseCheck = false;
        me.scrollbars.v.update();
        me.scrollbars.h.update();
        if (me.settings.preventParentScroll) {
          return Events.wheel(ev, me);
        }
      },
      touchend: function(ev, me) {
        return clearTimeout(me.cache.timerStop);
      },
      scrollStop: function(me) {
        me.fireCustomEvent('scrollstop');
        return G.pauseCheck = false;
      },
      wheel: function(ev, me) {
        var cache, cacheH, cacheV;
        cache = me.cache;
        cacheV = cache.v;
        cacheH = cache.h;
        if (cacheV.enabled && cacheV.percent % 100 === 0) {
          me.scrollEl.scrollTop = cacheV.percent ? cache.scrollH - cache.clientH - 1 : void 0;
        } else {
          1;
        }
        if (cacheH.enabled && cacheH.percent % 100 === 0) {
          return me.scrollEl.scrollLeft = cacheH.percent ? cache.scrollW - cache.clientW - 1 : void 0;
        } else {
          return 1;
        }
      }
    };
    Scrollbar = function(which, instance) {
      var animated, cache, clientSize, enabled, evNames, events, isVertical, parentEl, scrollEl, scrollProp, scrollSize, scrollbarCache, scrollbarEl, settings, sizeProp, trackEl, trackTransition;
      isVertical = which === 'v';
      parentEl = instance.element;
      scrollEl = instance.scrollEl;
      settings = instance.settings;
      cache = instance.cache;
      scrollbarCache = cache[which] = {};
      sizeProp = isVertical != null ? isVertical : {
        'H': 'W'
      };
      clientSize = 'client' + sizeProp;
      scrollSize = 'scroll' + sizeProp;
      scrollProp = isVertical ? 'scrollTop' : 'scrollLeft';
      evNames = isVertical ? ['top', 'bottom'] : ['left', 'right'];
      trackTransition = 'height 0.2s ease 0s, width 0.2s ease 0s, opacity 0.2s ease 0s';
      enabled = false;
      scrollbarEl = null;
      trackEl = null;
      animated = false;
      events = {
        dragData: null,
        dragStart: function(ev) {
          var evData;
          evData = ev.touches ? ev.touches[0] : ev;
          return events.dragData = {
            x: evData.pageX,
            y: evData.pageY,
            scroll: scrollEl[scrollProp]
          };
        },
        dragMove: function(ev) {
          var delta, deltaRatio, evData;
          evData = ev.touches ? ev.touches[0] : ev;
          delta;
          deltaRatio;
          if (!events.dragData) {
            return;
          }
          ev.preventDefault();
          delta = isVertical ? evData.pageY - events.dragData.y : evData.pageX - events.dragData.x;
          deltaRatio = delta / cache[clientSize];
          return scrollEl[scrollProp] = events.dragData.scroll + deltaRatio * cache[scrollSize];
        },
        dragEnd: function() {
          return events.dragData = null;
        }
      };
      return {
        toggle: function(bool) {
          enabled = bool;
          if (trackEl) {
            toggleClass(parentEl, which + 'track-on', enabled);
            if (enabled) {
              trackEl.style[G.cssTransition] = trackTransition;
            }
          }
          return scrollbarCache.enabled = enabled;
        },
        create: function() {
          scrollbarEl = document.createElement('div');
          trackEl = document.createElement('b');
          scrollbarEl.className = settings.classPrefix + '-' + which;
          trackEl.className = settings.classPrefix + '-' + which + 'track';
          scrollbarEl.appendChild(trackEl);
          parentEl.appendChild(scrollbarEl);
          if (settings.draggableTracks) {
            return this.bind(true);
          }
        },
        update: function() {
          var deltaPos, newDim, newRelPos, newSize, oldSize;
          if (!enabled && cache[clientSize] === cache[scrollSize]) {
            return;
          }
          newDim = this.calc();
          newSize = newDim.size;
          oldSize = scrollbarCache.size;
          newRelPos = (1 / newSize) * newDim.position * 100;
          deltaPos = Math.abs(newDim.position - (scrollbarCache.position || 0)) * cache[clientSize];
          if (newSize === 1 && enabled) {
            me.toggle(false);
          }
          if (newSize < 1 && !enabled) {
            me.toggle(true);
          }
          if (trackEl && enabled) {
            me.style(newRelPos, deltaPos, newSize, oldSize);
          }
          scrollbarCache = _extend(scrollbarCache, newDim);
          if (enabled) {
            return me.fireEdgeEv();
          }
        },
        style: function(newRelPos, deltaPos, newSize, oldSize) {
          if (newSize !== oldSize) {
            trackEl.style[isVertical ? 'height' : 'width'] = newSize * 100 + '%';
          }
          if (deltaPos) {
            me.animateTrack(G.isTouch && deltaPos > 20);
            return trackEl.style[G.cssTransform] = 'translate(' + (isVertical ? '0%,' + newRelPos + '%' : newRelPos + '%' + ',0%')(+')');
          }
        },
        animateTrack: function(animatePos) {
          if (animatePos || animated) {
            trackEl.style[G.cssTransition] = trackTransition + (animatePos ? ', ' + G.cssTransformDashed + ' 0.2s linear 0s' : '');
          }
          return animated = animatePos;
        },
        bind: function() {
          if (trackEl) {
            trackEl[method](type[0], events.dragStart);
          }
          document[method](type[1], events.dragMove);
          return document[method](type[2], events.dragEnd);
        },
        calc: function() {
          var percent, position, positionRatio, scrollS, sizeDiff, sizeRatio, viewS;
          position = scrollEl[scrollProp];
          viewS = cache[clientSize];
          scrollS = cache[scrollSize];
          sizeRatio = viewS / scrollS;
          sizeDiff = scrollS - viewS;
          if (sizeRatio >= 1 || !scrollS) {
            return {
              position: 0,
              size: 1,
              percent: 0
            };
          }
          percent = 100 * position / sizeDiff;
          if (position <= 1) {
            percent = 0;
          }
          if (position >= sizeDiff - 1) {
            percent = 100;
          }
          sizeRatio = Math.max(sizeRatio, settings.minTrackSize / 100);
          sizeRatio = Math.min(sizeRatio, settings.maxTrackSize / 100);
          positionRatio = (1 - sizeRatio) * (percent / 100);
          return {
            position: positionRatio,
            size: sizeRatio,
            percent: percent
          };
        },
        fireEdgeEv: function() {
          var percent;
          percent = scrollbarCache.percent;
          if (scrollbarCache.was !== percent && percent % 100 === 0) {
            instance.fireCustomEvent('scrollreachedge');
            instance.fireCustomEvent('scrollreach' + evNames[percent / 100]);
          }
          return scrollbarCache.was = percent;
        },
        remove: function() {
          this.toggle(false);
          this.bind(false);
          if (scrollbarEl && scrollbarEl.parentNode) {
            return scrollbarEl.parentNode.removeChild(scrollbarEl);
          }
        }
      };
    };
    Utils = {
      hideNativeScrollbars: function(scrollEl) {
        var scrollElStyle, size, time;
        size = G.nativeScrollbarSize;
        scrollElStyle = scrollEl.style;
        if (size === 0) {
          time = Date.now();
          scrollEl.setAttribute('data-scroll', time);
          scrollElStyle.display = 'none';
          if (G.isTouch) {
            Utils.addCssRule('[data-scroll="' + time + '"]::-webkit-scrollbar', 'display: none;');
          } else {
            Utils.addCssRule('[data-scroll="' + time + '"]::-webkit-scrollbar', 'width: 0; height: 0;');
          }
          return animationTimeout(function() {
            return scrollElStyle.display = 'block';
          });
        } else {
          scrollElStyle.overflow = 'scroll';
          scrollElStyle.right = -size + 'px';
          return scrollElStyle.bottom = -size + 'px';
        }
      },
      addCssRule: function(selector, rules) {
        var styleSheet;
        styleSheet = document.getElementById('scroll-sheet');
        if (!styleSheet) {
          styleSheet = document.createElement("style");
          styleSheet.id = 'scroll-sheet';
          document.head.appendChild(styleSheet);
        }
        return styleSheet.innerHTML += selector + "{" + rules + "} ";
      },
      containsNode: function(parent, node) {
        if (parent.contains) {
          return parent !== node && parent.contains(node);
        } else {
          return !!(parent.compareDocumentPosition(node) & 16);
        }
      },
      checkLoop: function() {
        if (!G.instances.length) {
          G.checkTimer = null;
          return;
        }
        if (!G.pauseCheck) {
          _invoke(G.instances, 'update');
        }
        if (GS.checkFrequency) {
          return G.checkTimer = setTimeout((function() {
            return Utils.checkLoop();
          }), GS.checkFrequency);
        }
      },
      easingFunction: function(t) {
        return (--t) * t * t + 1;
      }
    };
    animationTimeout = (function() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        return window.setTimeout(callback, 1000 / 60);
      };
    })();
    getScrollbarWidth = function() {
      var htmlEl, innerEl, outerEl, width;
      htmlEl = document.documentElement;
      width = 0;
      outerEl = document.createElement('div');
      outerEl.style.cssText = 'overflow:scroll;width:50px;height:50px;' + 'position:absolute;left:-100px';
      innerEl = document.createElement('div');
      innerEl.style.cssText = 'width:100px;height:100px';
      outerEl.appendChild(innerEl);
      htmlEl.appendChild(outerEl);
      width = outerEl.offsetWidth - outerEl.clientWidth;
      htmlEl.removeChild(outerEl);
      return width;
    };
    cssTest = function(prop) {
      var el, i, j, len, props, ucProp;
      el = document.createElement('test');
      ucProp = prop.charAt(0).toUpperCase() + prop.slice(1);
      props = (prop + ' ' + ['Webkit', 'Moz', 'O', 'ms'].join(ucProp + ' ') + ucProp).split(' ');
      for (j = 0, len = props.length; j < len; j++) {
        i = props[j];
        if (el.style[props[i]] !== void 0) {
          return props[i];
        }
      }
      return false;
    };
    toggleClass = function(el, value, bool) {
      var classes, index;
      classes = el.className.split(/\s+/);
      index = classes.indexOf(value);
      if (bool) {
        ~index || classes.push(value);
      } else {
        ~index && classes.splice(index, 1);
      }
      return el.className = classes.join(" ");
    };
    _extend = function(dest, src, merge) {
      var i, j, len;
      for (j = 0, len = src.length; j < len; j++) {
        i = src[j];
        if (!src.hasOwnProperty(i) || dest[i] !== void 0 && merge) {
          continue;
        }
        dest[i] = src[i];
      }
      return dest;
    };
    _invoke = function(collection, fn, args) {
      var i, j, k, len, len1, ref;
      console.log('dsadsadsad');
      console.log(collection.length);
      if (collection.length) {
        ref = collection.length;
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          console.log(i);
          collection[i][fn].apply(collection[i], args);
        }
      } else {
        collection['h'][fn].apply(collection['h'], args);
        collection['v'][fn].apply(collection['v'], args);
        for (k = 0, len1 = collection.length; k < len1; k++) {
          i = collection[k];
          console.log('ghfgfgdfgdf');
          collection[i][fn].apply(collection[i], args);
        }
      }
      return true;
    };
    _throttle = function(fn, threshhold) {
      return function() {
        var args, context, deferTimer, last, now;
        context = this;
        now = Date.now();
        args = arguments;
        if (last && now < last + threshhold) {
          clearTimeout(deferTimer);
          return deferTimer = setTimeout((function() {
            var last;
            last = now;
            return fn.apply(context, args);
          }), threshhold);
        } else {
          last = now;
          return fn.apply(context, args);
        }
      };
    };
    GS = Optiscroll.globalSettings = {
      scrollMinUpdateInterval: 1000 / 40,
      checkFrequency: 1000,
      pauseCheck: false
    };
    Optiscroll.defaults = {
      preventParentScroll: false,
      forceScrollbars: false,
      scrollStopDelay: 300,
      maxTrackSize: 95,
      minTrackSize: 5,
      draggableTracks: true,
      autoUpdate: true,
      classPrefix: 'optiscroll'
    };
    G = Optiscroll.G = {
      isTouch: indexOf.call(window, 'ontouchstart') >= 0,
      cssTransition: cssTest('transition'),
      cssTransform: cssTest('transform') || '',
      nativeScrollbarSize: getScrollbarWidth(),
      instances: [],
      checkTimer: null,
      pauseCheck: false
    };
    G.cssTransformDashed = G.cssTransform === 'transform' ? G.cssTransform : '-' + G.cssTransform.replace('T', '-t').toLowerCase();
    return Optiscroll;
  })();

  this.Optiscroll = Optiscroll;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Optiscroll;
  }

}).call(this);
